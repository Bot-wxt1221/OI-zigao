#include<cstring>
#define AC_TYPE char
#define QUEUE_TYPE int
const int MAX_N=200000+10;const int AC_DATA_SIZE=26;const int AC_TREE_SIZE=200000+10;const int QUEUE_SIZE=AC_TREE_SIZE;struct EDGE{int next,to;EDGE(){next=-1;return;}};struct FAIL_TREE{int head[MAX_N],nowm;EDGE tree[MAX_N];FAIL_TREE(){memset(head,-1,sizeof(head));nowm=0;return;}void addEdge(int u,int v){tree[nowm].next=head[u];head[u]=nowm;tree[nowm].to=v;++nowm;return;}};struct QUEUE{QUEUE_TYPE q[QUEUE_SIZE];int head,tail;QUEUE(){head=0;tail=-1;return;}void push(QUEUE_TYPE in){q[++tail]=in;return;}void pop(){head=head+1;return;}void pop_back(){tail=tail-1;return;}QUEUE_TYPE front(){return q[head];}QUEUE_TYPE back(){return q[tail];}void clear(){head=0;tail=-1;return;}bool empty(){if(tail+1==head)return true;else return false;}int size(){return tail-head+1;}QUEUE_TYPE read(int in){return q[head+in];}}q;struct AC{int tree[AC_TREE_SIZE][AC_DATA_SIZE],fail[AC_TREE_SIZE],val[AC_TREE_SIZE],cnt[MAX_N],book[MAX_N],nown,cntn;FAIL_TREE t;AC(){memset(tree,0,sizeof(tree));memset(fail,0,sizeof(fail));memset(val,0,sizeof(val));memset(cnt,0,sizeof(cnt));memset(book,0,sizeof(book));nown=0;cntn=0;return;}void insert(char*s,int len){int pos=0;for(register int i=0;i<len;++i)pos=tree[pos][s[i]]?tree[pos][s[i]]:(tree[pos][s[i]]=++nown);book[++cntn]=pos;return;}void build(){register int u;memset(fail,0,sizeof(fail));for(register int i=0;i<AC_DATA_SIZE;++i)if(tree[0][i])q.push(tree[0][i]);while(q.size()){int u=q.front();q.pop();for(register int i=0;i<AC_DATA_SIZE;++i)if(tree[u][i]){fail[tree[u][i]]=tree[fail[u]][i];q.push(tree[u][i]);}else tree[u][i]=tree[fail[u]][i];}return;}int find(char*s,int len){register int u=0,res=0;for(register int i=0;i<len;++i){u=tree[u][s[i]];++val[u];}for(register int i=1;i<=nown;++i)t.addEdge(fail[i],i);dfs(0);for(register int i=1;i<=cntn;++i)cnt[i]=val[book[i]];return res;}void dfs(int u){for(register int i=t.head[u];~i;i=t.tree[i].next){dfs(t.tree[i].to);val[u]+=val[t.tree[i].to];}return;}void clear(){memset(this,0,sizeof(AC));return;}};