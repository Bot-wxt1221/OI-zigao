/*
参加赌博，赌 M 次 ，每次都有 P 的概率下注金翻倍 ，（1-P）的概率输掉下注金 
每次可以下注任何数量的金币 
一开始有金币 x 个，问最后能带1000 000 个以上回家的概率 
//
分析：对于赌博，因为每次都能下注的金币是无限种可能的，所以，要将无限化有限（化连续为离散） 
对于最后一次赌博：
1.  本金>= 1000 000   概率为1（直接就走了） 
2.  本金>=5000 00     概率为P（赢了有，输了没） 
3.  本金<5000 00     概率为0  （不管输赢都没有1000 000） 
 
最后两轮：
1.本金  >=1000 000   概率为1
2. 本金 >=7500 00    概率为：P*P（两次都输才会输2500 00+5000 00）  
3. 本金 >=5000 00    概率为：P（赢一次直接走，输了必定不可能到1000 000） 
4. 本金 >=2500 00    概率为：（1-P）*（1-P）必须两次都赢 
5. 本金 <2500 00     概率为：0   别想了 
. . . .
. . . .
某个范围内，即使所持的钱数不同，最后可以带钱回家的概率也是相同的 
 
M轮 考虑 2^M+1 种情况  
 
*/
 
double dp[2][1000005];//滚动数组 
void solve()
{
	int input(M,X);
	double input(P);
	
	int n=1<<M;//n=2^M 
	double *prv=dp[0],*nxt=dp[1];
	clean(dp,0);
	prv[n]=1.0;//第一行末尾 1.0 
	for(int r=0;r<M;++r)//M次赌博 
	{
		for(int i=0;i<=n;++i)// n个状态 
		{
			int jub=min(i,n-i);
			double t=0.0;
			for(int j=0;j<=jub;++j)//比较 0 ~ min(i，n-i) 
				t=max(t,P*prv[i+j]+(1-P*prv[i-j]));
			
			nxt[i]=t;
		}
		swap(prv,nxt);//滚动数组 
	}
	int i=ll(X*n)/1000000;
	printf("%.6lf\n",prv[i]);
}
